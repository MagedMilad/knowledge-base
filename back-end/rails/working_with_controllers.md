# Working with Controllers

## 1.  Rack
## 1.1 Rake Middleware
Rack is a modular interface for handling web requests, written in Ruby

It abstracts away the handling of HTTP requests and responses into a single, simple `call` method

it is essential Rails 4 knowledge to understand that much of Action Controller is implemented as Rack middleware modules. Want to see which Rack filters are enabled for your Rails 5 application?

```bash
$ rake middleware
```
```ruby
use Rack::Sendfile
use ActionDispatch::Static
use ActionDispatch::Executor
use ActiveSupport::Cache::Strategy::LocalCache::Middleware
use Rack::Runtime
use Rack::MethodOverride
use ActionDispatch::RequestId
use Sprockets::Rails::QuietAssets
use Rails::Rack::Logger
use ActionDispatch::ShowExceptions
use WebConsole::Middleware
use ActionDispatch::DebugExceptions
use ActionDispatch::RemoteIp
use ActionDispatch::Reloader
use ActionDispatch::Callbacks
use ActiveRecord::Migration::CheckPending
use ActionDispatch::Cookies
use ActionDispatch::Session::CookieStore
use ActionDispatch::Flash
use Rack::Head
use Rack::ConditionalGet
use Rack::ETag
run SampleApp::Application.routes
```

## 1.2 Configuring Your Middleware Stack
Your application object allows you to access and manipulate the Rack middleware stack during initialization,
via `config.middleware` in `config/application.rb`
you can insert your custome middleware in any position 

you can insert, delete, swap middlewares using `config.middleware`

## 1.3 Action Dispatch: Where It All Begins

The entry point to a request is an instance of `ActionDispatch::Routing::RouteSet` , the object on which you
can call draw at the top of `config/routes.rb` .

The route set chooses the rule that matches, and calls its Rack endpoint. So a route like
```ruby
get 'foo', to: 'foo#index'
```
has a dispatcher instance associated to it, whose call method ends up executing
```ruby
FooController.action(:index).call
```

## 2 Explicit Rendering
every controller action has an implicit render command in it. And render is a real method.

#### 2.1 render another action template 
```ruby
render action: 'create'
```

#### 2.2 render any template
```ruby
render template: '/users/index'
```

#### 2.3 render partial view
```ruby
render partial: 'shared/product'
render partial: @product
render @product
render 'product'
```
all of them will render `products/_product.html.erb`

#### 2.4 render any type

```ruby
render text: 'hello word'
render json: @user
render json: {created: true}
render json: @records, callback: 'updateRecordsDisplay'
render xml: @user
render nothing: true
```

#### 2.5 render options
```ruby
:content_type
:layout
:status
```

You can specify layout options at the controller class level if you want to reuse layouts for multiple actions.

```ruby
class EventController < ActionController::Base
    layout "events", only: [:index, :new]
    layout "global", except: [:index, :new]
end
```

## 3 redirecting
The main reason to redirect rather than just render a template after creating or editing a resource (really a
POST action) has to do with browser reload behavior. If you didn’t redirect, the user would be prompted to
re-submit the form if they hit the back button or reload.

#### 3.1 The redirect_to Method
```ruby
redirect_to(target, response_status = {})
```
The `target` parameter takes one of several forms.

- Hash

The URL will be generated by calling `url_for` with the argument provided.

```ruby
redirect_to action: "show", id: 5
# /users/show/5
```

- Active Record object

```ruby
redirect_to post
```

- url with protocol

```ruby
redirect_to "http://www.google.com"
redirect_to  users_url
```

- url without protocol

```ruby
redirect_to '/'
redirect_to users_path
```

- back

```ruby
redirect_to :back
```

## 4 Action Callbacks

```ruby
before_action :require_authentication
after_action :logging
around_action :catch_exceptions
```

#### 4.1 Action Callback Types

- Action Callback Classes

Using an external class makes for more easily reused generic callbacks, such as output compression. External
callback classes are implemented by having a static callback method on any class and then passing this class to
the action callback method, as in Listing The name of the class method should match the type of callback
desired (eg: `before`, `after`, `around`).

```ruby
class OutputCompressionActionCallback
    def self.after(controller)
        controller.response.body = compress(controller.response.body)
    end
end

class NewspaperController < ActionController::Base
    after_action OutputCompressionActionCallback
end
```

- Inline Method
```ruby
class WeblogController < ActionController::Base
    before_action do
        redirect_to new_user_session_path unless authenticated?
    end
end
```

#### 4.2 Action Callback Chain Ordering
you can use `prepend_before_action` and `prepend_after_action` . Callbacks added by these methods
will be put at the beginning of their respective chain and executed before the rest

```ruby
class ShoppingController < ActionController::Base
    before_action :verify_open_shop
end

class CheckoutController < ShoppingController
    prepend_before_action :ensure_items_in_cart, :ensure_items_in_stock
end
```
The action callback chain for the CheckoutController is now `:ensure_items_in_cart` , `:ensure_items_in_-
stock` , `:verify_open_shop` . So if either of the ensure callbacks halts execution, we’ll never get around to
seeing if the shop is open.

#### 4.3 Action Callback Chain Skipping
```ruby
skip_before_action :authenticate
skip_action_callback :catch_exceptions
```
#### 4.4 Action Callback Condition
```ruby
before_action :authenticate, only: [:show]
before_action :authenticate, except: [:show]
```




